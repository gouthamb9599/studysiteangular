import { Injectable, ɵɵdefineInjectable, InjectionToken, Inject, forwardRef, ɵɵinject, EventEmitter, Directive, ElementRef, Input, Output, NgModule } from '@angular/core';
import { Chart } from 'chart.js';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StoreService {
    constructor() {
        this._chartInstances = [];
        this._chartId = [];
    }
    /**
     * @param {?} id
     * @param {?} chart
     * @return {?}
     */
    addChart(id, chart) {
        for (let i = 0; i < this._chartId.length; i++) {
            if (id === this._chartId[i]) {
                return;
            }
        }
        this._chartId.push(id);
        this._chartInstances.push(chart);
    }
    /**
     * @param {?} id
     * @return {?}
     */
    removeChart(id) {
        for (let i = 0; i < this._chartId.length; i++) {
            if (id === this._chartId[i]) {
                this._chartId.splice(i, 1);
                this._chartInstances.splice(i, 1); // delete chart instance.
            }
        }
    }
    /**
     * @param {?} id
     * @return {?}
     */
    getChart(id) {
        for (let i = 0; i < this._chartId.length; i++) {
            if (id === this._chartId[i]) {
                return this._chartInstances[i];
            }
        }
        return null;
    }
}
StoreService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ StoreService.ngInjectableDef = ɵɵdefineInjectable({ factory: function StoreService_Factory() { return new StoreService(); }, token: StoreService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    StoreService.prototype._chartInstances;
    /**
     * @type {?}
     * @private
     */
    StoreService.prototype._chartId;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const NgChartjsDefaultPluginToken = new InjectionToken('[ngx-chart-js] Global Default Plugin');
/** @type {?} */
const NgChartjsCustomPluginToken = new InjectionToken('[ngx-chart-js] Global Custom Plugin');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PluginConfig {
    /**
     * @param {?=} plugins
     */
    constructor(plugins = []) {
        this._plugins = plugins;
    }
    /**
     * @return {?}
     */
    get plugins() {
        return this._plugins;
    }
}
if (false) {
    /**
     * @type {?}
     * @private
     */
    PluginConfig.prototype._plugins;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgChartjsService {
    /**
     * @param {?} pluginConfig
     * @param {?} storeService
     */
    constructor(pluginConfig, storeService) {
        this.pluginConfig = pluginConfig;
        this.storeService = storeService;
        this.plugins = pluginConfig.plugins;
        if (this.plugins.length !== 0 || this.plugins) {
            for (let i = 0; i < this.plugins.length; i++) {
                if (this.plugins[i]) {
                    Chart.plugins.register(this.plugins[i]);
                }
            }
        }
    }
    // get chart instance by id
    /**
     * @param {?} id
     * @return {?}
     */
    getChart(id) {
        return this.storeService.getChart(id);
    }
}
NgChartjsService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
NgChartjsService.ctorParameters = () => [
    { type: PluginConfig, decorators: [{ type: Inject, args: [forwardRef((/**
                     * @return {?}
                     */
                    () => NgChartjsCustomPluginToken)),] }] },
    { type: StoreService }
];
/** @nocollapse */ NgChartjsService.ngInjectableDef = ɵɵdefineInjectable({ factory: function NgChartjsService_Factory() { return new NgChartjsService(ɵɵinject(NgChartjsCustomPluginToken), ɵɵinject(StoreService)); }, token: NgChartjsService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    NgChartjsService.prototype.plugins;
    /**
     * @type {?}
     * @private
     */
    NgChartjsService.prototype.pluginConfig;
    /**
     * @type {?}
     * @private
     */
    NgChartjsService.prototype.storeService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function Color() { }
if (false) {
    /** @type {?|undefined} */
    Color.prototype.backgroundColor;
    /** @type {?|undefined} */
    Color.prototype.borderWidth;
    /** @type {?|undefined} */
    Color.prototype.borderColor;
    /** @type {?|undefined} */
    Color.prototype.borderCapStyle;
    /** @type {?|undefined} */
    Color.prototype.borderDash;
    /** @type {?|undefined} */
    Color.prototype.borderDashOffset;
    /** @type {?|undefined} */
    Color.prototype.borderJoinStyle;
    /** @type {?|undefined} */
    Color.prototype.pointBorderColor;
    /** @type {?|undefined} */
    Color.prototype.pointBackgroundColor;
    /** @type {?|undefined} */
    Color.prototype.pointBorderWidth;
    /** @type {?|undefined} */
    Color.prototype.pointRadius;
    /** @type {?|undefined} */
    Color.prototype.pointHoverRadius;
    /** @type {?|undefined} */
    Color.prototype.pointHitRadius;
    /** @type {?|undefined} */
    Color.prototype.pointHoverBackgroundColor;
    /** @type {?|undefined} */
    Color.prototype.pointHoverBorderColor;
    /** @type {?|undefined} */
    Color.prototype.pointHoverBorderWidth;
    /** @type {?|undefined} */
    Color.prototype.pointStyle;
    /** @type {?|undefined} */
    Color.prototype.hoverBackgroundColor;
    /** @type {?|undefined} */
    Color.prototype.hoverBorderColor;
    /** @type {?|undefined} */
    Color.prototype.hoverBorderWidth;
}
// Default colors
/** @type {?} */
const DefaultColors = [
    [63, 81, 181],
    [255, 152, 0],
    [233, 30, 99],
    [156, 39, 176],
    [0, 188, 212],
    [3, 169, 244],
    [0, 150, 136],
    [96, 125, 139],
    [255, 193, 7],
    [37, 155, 36],
    [205, 220, 57],
    [86, 119, 252] // Blue
];
/**
 * @record
 */
function Colors() { }
if (false) {
    /** @type {?|undefined} */
    Colors.prototype.data;
    /** @type {?|undefined} */
    Colors.prototype.label;
}
/**
 * @param {?} colour
 * @param {?} alpha
 * @return {?}
 */
function rgba(colour, alpha) {
    return 'rgba(' + colour.concat(alpha).join(',') + ')';
}
/**
 * @param {?} min
 * @param {?} max
 * @return {?}
 */
function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}
/**
 * @param {?} colors
 * @return {?}
 */
function formatLineColor(colors) {
    return {
        backgroundColor: rgba(colors, 0.4),
        borderColor: rgba(colors, 1),
        pointBackgroundColor: rgba(colors, 1),
        pointBorderColor: '#fff',
        pointHoverBackgroundColor: '#fff',
        pointHoverBorderColor: rgba(colors, 0.8)
    };
}
/**
 * @param {?} colors
 * @return {?}
 */
function formatBarColor(colors) {
    return {
        backgroundColor: rgba(colors, 0.6),
        borderColor: rgba(colors, 1),
        hoverBackgroundColor: rgba(colors, 0.8),
        hoverBorderColor: rgba(colors, 1)
    };
}
/**
 * @param {?} colors
 * @return {?}
 */
function formatPieColors(colors) {
    return {
        backgroundColor: colors.map((/**
         * @param {?} color
         * @return {?}
         */
        (color) => rgba(color, 0.6))),
        borderColor: colors.map((/**
         * @return {?}
         */
        () => '#fff')),
        pointBackgroundColor: colors.map((/**
         * @param {?} color
         * @return {?}
         */
        (color) => rgba(color, 1))),
        pointBorderColor: colors.map((/**
         * @return {?}
         */
        () => '#fff')),
        pointHoverBackgroundColor: colors.map((/**
         * @param {?} color
         * @return {?}
         */
        (color) => rgba(color, 1))),
        pointHoverBorderColor: colors.map((/**
         * @param {?} color
         * @return {?}
         */
        (color) => rgba(color, 1)))
    };
}
/**
 * @param {?} colors
 * @return {?}
 */
function formatPolarAreaColors(colors) {
    return {
        backgroundColor: colors.map((/**
         * @param {?} color
         * @return {?}
         */
        (color) => rgba(color, 0.6))),
        borderColor: colors.map((/**
         * @param {?} color
         * @return {?}
         */
        (color) => rgba(color, 1))),
        hoverBackgroundColor: colors.map((/**
         * @param {?} color
         * @return {?}
         */
        (color) => rgba(color, 0.8))),
        hoverBorderColor: colors.map((/**
         * @param {?} color
         * @return {?}
         */
        (color) => rgba(color, 1)))
    };
}
/**
 * @return {?}
 */
function getRandomColor() {
    return [getRandomInt(0, 255), getRandomInt(0, 255), getRandomInt(0, 255)];
}
/**
 * \@method Generate colors for line|bar charts
 * @author vincent 2019-01-22
 * @version 0.0.0
 * \@example
 * \@log 1. vincent,2019-01-22,done
 * @param {?} index he index of the default color array. eg. 0, 1
 * @return {?} number[]
 */
function generateColor(index) {
    return DefaultColors[index] || getRandomColor();
}
/**
 * \@method Generate colors for pie|doughnut charts
 * @author vincent 2019-01-22
 * @version 0.0.0
 * \@example
 * \@log 1. vincent,2019-01-22,done
 * @param {?} count Length of data. eg. datasets.data.length
 * @return {?} number[][]
 */
function generateColors(count) {
    /** @type {?} */
    const colorsArr = new Array(count);
    for (let i = 0; i < count; i++) {
        colorsArr[i] = DefaultColors[i] || getRandomColor();
    }
    return colorsArr;
}
/**
 * \@method Generate colors by chart type
 * @author vincent 2019-01-22
 * @version 0.0.0
 * \@example
 * \@log 1. vincent,2019-01-22,done
 * @param {?} chartType The type of chart you are using. eg. line,bar
 * @param {?} index The index of the default color array. eg. DefaultColors[index]
 * @param {?} count Length of data. eg. datasets.data.length
 * @return {?} Color or number[]
 */
function getColors(chartType, index, count) {
    if (chartType === 'pie' || chartType === 'doughnut') {
        return formatPieColors(generateColors(count));
    }
    if (chartType === 'polarArea') {
        return formatPolarAreaColors(generateColors(count));
    }
    if (chartType === 'line' || chartType === 'radar') {
        return formatLineColor(generateColor(index));
    }
    if (chartType === 'bar' || chartType === 'horizontalBar') {
        return formatBarColor(generateColor(index));
    }
    return generateColor(index);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/* tslint:disable-next-line */
class NgChartjsDirective {
    /**
     * @param {?} element
     * @param {?} ngChartjsService
     * @param {?} storeService
     */
    constructor(element, ngChartjsService, storeService) {
        this.ngChartjsService = ngChartjsService;
        this.storeService = storeService;
        // x轴标签。这对图表来说是必要的：线，条和雷达。并且只是图表的标签（悬停）：polarArea，pie和doughnut
        this.labels = [];
        // 相当于chart.js的option
        this.options = {};
        // 鼠标点击图表所有的区域
        this.chartClick = new EventEmitter();
        // 鼠标悬浮在标签或者活跃的点上面时
        this.chartHover = new EventEmitter();
        this.initFlag = false;
        this.hasChanges = false;
        this.element = element; // 获取指令所在canvas元素
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.ctx = this.element.nativeElement.getContext('2d'); // 获取元素的ctx
        this.initFlag = true; // 是否初始化了的标志
        if (this.data || this.datasets) { // 判断data和datasets有一个有数据就刷新
            this.refresh();
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        // TODO: 插件变化刷新，开放刷新按钮
        if (this.initFlag) {
            // Check if the changes are in the data or datasets
            if (changes.hasOwnProperty('data') || changes.hasOwnProperty('datasets')) {
                if (changes.data) {
                    this.updateChartData(changes.data.currentValue);
                }
                else {
                    this.updateChartData(changes.datasets.currentValue);
                }
                this.hasChanges = true;
            }
            if (changes.hasOwnProperty('labels')) {
                this.chart.data.labels = changes.labels.currentValue;
                this.hasChanges = true;
            }
            if (changes.hasOwnProperty('legend')) {
                if (changes.legend.currentValue !== changes.legend.previousValue) {
                    this.chart.options.legend.display = changes.legend.currentValue;
                    this.hasChanges = true;
                }
            }
            if (changes.hasOwnProperty('adding')) {
                this.addData(changes.adding.currentValue.labels, changes.adding.currentValue.data);
                this.hasChanges = true;
            }
            if (changes.hasOwnProperty('removing')) {
                if (changes.removing.currentValue.orientation === 'oldest' || changes.removing.currentValue.orientation === 'latest') {
                    this.removeData(changes.removing.currentValue.orientation);
                    this.hasChanges = true;
                }
            }
            if (changes.hasOwnProperty('chartType')) {
                this.refresh();
            }
            if (changes.hasOwnProperty('resetOption')) {
                Object.assign(this.chart.options, changes.resetOption.currentValue);
                this.hasChanges = true;
            }
            if (this.hasChanges) {
                this.chart.update();
                this.hasChanges = false;
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.chart) {
            this.chart.destroy();
            this.chart = void 0;
            if (this.element.nativeElement.hasAttribute('id')) {
                this.storeService.removeChart(this.element.nativeElement.id); // delete chart instance.
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    refresh() {
        this.ngOnDestroy();
        this.chart = this.getChartBuilder(this.ctx /*, data, this.options*/);
        if (this.element.nativeElement.hasAttribute('id')) {
            this.storeService.addChart(this.element.nativeElement.id, this.chart);
        }
    }
    /**
     * @private
     * @param {?} labels
     * @param {?} data
     * @return {?}
     */
    addData(labels, data) {
        if (labels.length === 0 || data.length === 0) {
            return;
        }
        // update labels
        labels.forEach((/**
         * @param {?} label
         * @return {?}
         */
        (label) => { this.chart.data.labels.push(label); }));
        this.chart.data.datasets.forEach((/**
         * @param {?} dataset
         * @param {?} index
         * @return {?}
         */
        (dataset, index) => {
            if (data[index]) {
                for (let i = 0; i < data[index].length; i++) {
                    dataset.data.push(data[index][i]);
                }
            }
            else {
                console.log('The added data does not match the original data');
                return;
            }
        }));
    }
    // direction is 'ildest' or 'latest'
    /**
     * @private
     * @param {?} direction
     * @return {?}
     */
    removeData(direction) {
        if (direction === 'latest') {
            this.chart.data.labels.pop();
            this.chart.data.datasets.forEach((/**
             * @param {?} dataset
             * @return {?}
             */
            (dataset) => {
                dataset.data.pop();
            }));
            return;
        }
        if (direction === 'oldest') {
            return;
        }
    }
    /**
     * @private
     * @param {?} newDataValues
     * @return {?}
     */
    updateChartData(newDataValues) {
        if (Array.isArray(newDataValues[0].data)) {
            this.chart.data.datasets.forEach((/**
             * @param {?} dataset
             * @param {?} i
             * @return {?}
             */
            (dataset, i) => {
                dataset.data = newDataValues[i].data;
                if (newDataValues[i].label) {
                    dataset.label = newDataValues[i].label;
                }
            }));
        }
        else {
            this.chart.data.datasets[0].data = newDataValues;
        }
    }
    /**
     * @param {?} ctx
     * @return {?}
     */
    getChartBuilder(ctx /*, data:Array<any>, options:any*/) {
        /** @type {?} */
        const datasets = this.getDatasets();
        /** @type {?} */
        const options = Object.assign({}, this.options);
        if (this.legend === false) { // 设置options的legend TODO: 后续这个属性去除，直接在options内设置
            options.legend = { display: false };
        }
        // hock for onHover and onClick events
        options.hover = options.hover || {};
        if (!options.hover.onHover) {
            options.hover.onHover = (/**
             * @param {?} event
             * @param {?} active
             * @return {?}
             */
            (event, active) => {
                if (active && !active.length) {
                    return;
                }
                this.chartHover.emit({ event, active });
            });
        }
        if (!options.onClick) {
            options.onClick = (/**
             * @param {?} event
             * @param {?} active
             * @return {?}
             */
            (event, active) => {
                this.chartClick.emit({ event, active });
            });
        }
        /** @type {?} */
        const opts = {
            type: this.chartType,
            data: {
                labels: this.labels,
                datasets: datasets // TODO: 后续更改这个属性名字，否则警告
            },
            options: options,
            // TODO: 后续更改这个属性名字，否则警告
            plugins: this.inlinePlugins
        };
        return new Chart(ctx, opts);
    }
    // 获取 chart.js的datasets数据
    /**
     * @private
     * @return {?}
     */
    getDatasets() {
        /** @type {?} */
        let datasets = void 0;
        // in case if datasets is not provided, but data is present
        if (!this.datasets || !this.datasets.length && (this.data && this.data.length)) {
            if (Array.isArray(this.data[0])) {
                datasets = ((/** @type {?} */ (this.data))).map((/**
                 * @param {?} data
                 * @param {?} index
                 * @return {?}
                 */
                (data, index) => {
                    return { data, label: this.labels[index] || `Label ${index}` };
                }));
            }
            else {
                datasets = [{ data: this.data, label: `Label 0` }];
            }
        }
        if (this.datasets && this.datasets.length || (datasets && datasets.length)) {
            // fix elm type, pre type is number
            datasets = (this.datasets || datasets).map((/**
             * @param {?} elm
             * @param {?} index
             * @return {?}
             */
            (elm, index) => {
                /** @type {?} */
                const newElm = Object.assign({}, elm);
                if (this.colors && this.colors.length) {
                    Object.assign(newElm, this.colors[index]);
                }
                else {
                    Object.assign(newElm, getColors(this.chartType, index, newElm.data.length));
                }
                return newElm;
            }));
        }
        if (!datasets) {
            throw new Error(`ng-charts configuration error,
      data or datasets field are required to render char ${this.chartType}`);
        }
        return datasets;
    }
}
NgChartjsDirective.decorators = [
    { type: Directive, args: [{ selector: 'canvas[ngChartjs]', exportAs: 'ng-chart-js' },] }
];
/** @nocollapse */
NgChartjsDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgChartjsService },
    { type: StoreService }
];
NgChartjsDirective.propDecorators = {
    data: [{ type: Input }],
    datasets: [{ type: Input }],
    labels: [{ type: Input }],
    options: [{ type: Input }],
    inlinePlugins: [{ type: Input }],
    chartType: [{ type: Input }],
    colors: [{ type: Input }],
    legend: [{ type: Input }],
    adding: [{ type: Input }],
    removing: [{ type: Input }],
    resetOption: [{ type: Input }],
    chartClick: [{ type: Output }],
    chartHover: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    NgChartjsDirective.prototype.data;
    /** @type {?} */
    NgChartjsDirective.prototype.datasets;
    /** @type {?} */
    NgChartjsDirective.prototype.labels;
    /** @type {?} */
    NgChartjsDirective.prototype.options;
    /** @type {?} */
    NgChartjsDirective.prototype.inlinePlugins;
    /** @type {?} */
    NgChartjsDirective.prototype.chartType;
    /** @type {?} */
    NgChartjsDirective.prototype.colors;
    /** @type {?} */
    NgChartjsDirective.prototype.legend;
    /** @type {?} */
    NgChartjsDirective.prototype.adding;
    /** @type {?} */
    NgChartjsDirective.prototype.removing;
    /** @type {?} */
    NgChartjsDirective.prototype.resetOption;
    /** @type {?} */
    NgChartjsDirective.prototype.chartClick;
    /** @type {?} */
    NgChartjsDirective.prototype.chartHover;
    /** @type {?} */
    NgChartjsDirective.prototype.ctx;
    /** @type {?} */
    NgChartjsDirective.prototype.chart;
    /**
     * @type {?}
     * @private
     */
    NgChartjsDirective.prototype.initFlag;
    /**
     * @type {?}
     * @private
     */
    NgChartjsDirective.prototype.hasChanges;
    /**
     * @type {?}
     * @private
     */
    NgChartjsDirective.prototype.element;
    /**
     * @type {?}
     * @private
     */
    NgChartjsDirective.prototype.ngChartjsService;
    /**
     * @type {?}
     * @private
     */
    NgChartjsDirective.prototype.storeService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} plugins
 * @return {?}
 */
function ngChartjsCustomPluginsFactory(plugins) {
    return new PluginConfig(plugins);
}
/**
 * @return {?}
 */
function ngChartjsDefaultPluginsFactory() {
    return new PluginConfig([]);
}
class NgChartjsModule {
    /**
     * Register a plugin.
     * @param {?=} plugins
     * @return {?}
     */
    static registerPlugin(plugins = []) {
        return {
            ngModule: NgChartjsModule,
            providers: [
                {
                    provide: NgChartjsDefaultPluginToken,
                    useValue: plugins
                },
                {
                    deps: [NgChartjsDefaultPluginToken],
                    provide: NgChartjsCustomPluginToken,
                    useFactory: ngChartjsCustomPluginsFactory
                }
            ]
        };
    }
}
NgChartjsModule.decorators = [
    { type: NgModule, args: [{
                imports: [],
                declarations: [NgChartjsDirective],
                exports: [NgChartjsDirective],
                providers: [
                    NgChartjsService,
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { DefaultColors, NgChartjsDirective, NgChartjsModule, NgChartjsService, formatBarColor, formatLineColor, formatPieColors, formatPolarAreaColors, generateColor, generateColors, getColors, getRandomColor, getRandomInt, ngChartjsCustomPluginsFactory, ngChartjsDefaultPluginsFactory, rgba, NgChartjsDefaultPluginToken as ɵa, NgChartjsCustomPluginToken as ɵb, PluginConfig as ɵc, StoreService as ɵd };
//# sourceMappingURL=ng-chartjs.js.map
